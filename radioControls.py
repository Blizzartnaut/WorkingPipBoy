import subprocess
import csv
import time
import os
import threading

def scan_band(band_name, start_freq, end_freq, step, integration_time, threshold, output_csv):
    """
    Run rtl_power over a frequency range and return a list of candidate frequencies
    where the signal strength exceeds 'threshold' (in dB).
    
    Parameters:
      band_name (str): A label for the band (e.g., "FM")
      start_freq (float): Start frequency in Hz.
      end_freq (float): End frequency in Hz.
      step (float): Step size in Hz.
      integration_time (float): Integration time per measurement (in seconds).
      threshold (float): Minimum power (in dB) to be considered a candidate.
      output_csv (str): The filename for the CSV output.
      
    Returns:
      List of candidate frequencies (floats in Hz), sorted in ascending order.
    """
    # Build the rtl_power command.
    # Example: rtl_power -f 88000000:108000000:200000 -i 0.5 -E 1 -F csv > fm_scan.csv
    cmd = f"rtl_power -f {start_freq}:{end_freq}:{step} -i {integration_time} -1 {output_csv}"
    print("Running command:", cmd)
    
    # Run the command (blocking call).
    subprocess.run(cmd, shell=True)
    # Give a short delay to ensure the file is written.
    time.sleep(11)
    
    candidates = []
    if os.path.exists(output_csv):
        with open(output_csv, newline='') as csvfile:
            reader = csv.reader(csvfile)
            # Example CSV row: "Frequency, Power" (adjust indices as needed)
            for row in reader:
                try:
                    freq = float(row[0])
                    power = float(row[1])
                    # If the measured power is above our threshold, add to candidates.
                    if power > threshold:
                        candidates.append(freq)
                except Exception as e:
                    # Skip header lines or malformed rows.
                    continue
    candidates.sort()
    print(f"Found {len(candidates)} candidate frequencies in band {band_name}")
    return candidates

def seek_next(current_freq, candidates):
    """Return the first candidate frequency greater than current_freq; wrap around if needed."""
    for freq in candidates:
        if freq > current_freq:
            return freq
    return candidates[0] if candidates else current_freq

def seek_previous(current_freq, candidates):
    """Return the last candidate frequency less than current_freq; wrap around if needed."""
    for freq in reversed(candidates):
        if freq < current_freq:
            return freq
    return candidates[-1] if candidates else current_freq

def parse_rtl_power_csv(filename, threshold=10):
    """
    Reads an rtl_power CSV file and returns a sorted list of candidate frequencies
    that exceed 'threshold' dB.
    
    :param filename: Path to the CSV file generated by rtl_power.
    :param threshold: Minimum dB level to be considered a 'strong' signal.
    :return: A sorted list of candidate frequencies (floats in Hz).
    """
    candidates = []

    with open(filename, 'r', newline='') as csvfile:
        # Many rtl_power outputs are space or tab separated, so we can split on whitespace:
        reader = csv.reader(csvfile, delimiter=',', skipinitialspace=True)

        for row in reader:
            # Skip rows that don't have enough columns
            if len(row) < 7:
                continue

            try:
                # Parse the known columns
                start_freq = float(row[2])   # in Hz
                end_freq   = float(row[3])   # in Hz
                bin_size   = float(row[4])   # in Hz
                # row[5] is FFT size (we won't necessarily need it)
                
                # The remaining columns in row[6:] are power values in dB
                power_values = [float(x) for x in row[6:]]

                # For each sub-bin i, the frequency is start_freq + i * bin_size
                for i, pwr in enumerate(power_values):
                    if pwr > threshold:
                        freq_candidate = start_freq + i * bin_size
                        candidates.append(freq_candidate)
            except ValueError:
                # Could not parse the row properly, skip it
                continue
            except IndexError:
                # If something is out of range, skip it
                continue

    # Remove duplicates (if any) and sort
    unique_candidates = sorted(set(candidates))
    return unique_candidates


# Example usage:
def stong_freq():
    filename = "/home/marceversole/WorkingPipBoy/fm_scan.csv"
    threshold = 10  # Adjust threshold as needed
    strong_freqs = parse_rtl_power_csv(filename, threshold=threshold)
    print(f"Found {len(strong_freqs)} strong frequencies above {threshold} dB:")
    for freq in strong_freqs:
        print(f"{freq/1e6:.3f} MHz")
    return strong_freqs

scan_thread = threading.Thread(target=scan_band)
scan_thread.start()